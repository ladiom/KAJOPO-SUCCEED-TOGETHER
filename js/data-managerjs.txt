// Database Manager - Replaces localStorage operations with Supabase
class DatabaseManager {
    constructor() {
        this.supabase = null;
        this.initializationPromise = this.initializeSupabase();
    }

    async initializeSupabase() {
        // Wait for Supabase client to be available
        let attempts = 0;
        const maxAttempts = 50; // 5 seconds max wait
        
        while (!window.supabaseClient && attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }
        
        if (window.supabaseClient) {
            this.supabase = window.supabaseClient;
            console.log('DatabaseManager: Supabase client initialized successfully');
            return true;
        } else {
            console.error('DatabaseManager: Failed to initialize Supabase client after 5 seconds');
            return false;
        }
    }

    async ensureInitialized() {
        if (!this.supabase) {
            await this.initializationPromise;
        }
        return this.supabase !== null;
    }

    // ==================== USER MANAGEMENT ====================
    
    async registerUser(userData) {
        try {
            if (!(await this.ensureInitialized())) {
                throw new Error('Supabase client not available');
            }
            
            // Register with Supabase Auth
            const { data: authData, error: authError } = await this.supabase.auth.signUp({
                email: userData.email,
                password: userData.password,
                options: {
                    data: {
                        full_name: userData.fullName,
                        user_type: userData.userType,
                        phone: userData.phone
                    }
                }
            });
            
            if (authError) throw authError;
            
            // Insert additional user data into users table and wait for completion
            if (authData.user) {
                const { data: userRecord, error: userError } = await this.supabase
                    .from('users')
                    .insert([{
                        id: authData.user.id,
                        email: userData.email,
                        full_name: userData.fullName,
                        user_type: userData.userType,
                        phone: userData.phone,
                        created_at: new Date().toISOString()
                    }])
                    .select();
                
                if (userError) {
                    console.error('User record creation failed:', userError);
                    throw userError;
                }
                
                // Verify user record was created successfully
                if (!userRecord || userRecord.length === 0) {
                    throw new Error('User record creation failed - no record returned');
                }
                
                // Add a small delay to ensure database consistency
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            return { success: true, data: authData };
        } catch (error) {
            console.error('Registration error:', error);
            return { success: false, error: error.message };
        }
    }
// ... existing code ...

// Add these new methods to the DatabaseManager class
async getUniqueCategories() {
    try {
        if (!(await this.ensureInitialized())) {
            throw new Error('Supabase client not available');
        }
        const { data, error } = await this.supabase
            .from('opportunities')
            .select('category')
            .not('category', 'is', null);
        
        if (error) throw error;
        
        const uniqueCategories = [...new Set(data.map(item => item.category))]
            .filter(category => category && category.trim() !== '')
            .sort();
        
        return { success: true, data: uniqueCategories };
    } catch (error) {
        console.error('Get unique categories error:', error);
        return { success: false, error: error.message };
    }
}

async getUniqueTypes() {
    try {
        if (!(await this.ensureInitialized())) {
            throw new Error('Supabase client not available');
        }
        const { data, error } = await this.supabase
            .from('opportunities')
            .select('type')
            .not('type', 'is', null);
        
        if (error) throw error;
        
        const uniqueTypes = [...new Set(data.map(item => item.type))]
            .filter(type => type && type.trim() !== '')
            .sort();
        
        return { success: true, data: uniqueTypes };
    } catch (error) {
        console.error('Get unique types error:', error);
        return { success: false, error: error.message };
    }
}

async getUniqueLocations() {
    try {
        if (!(await this.ensureInitialized())) {
            throw new Error('Supabase client not available');
        }
        const { data, error } = await this.supabase
            .from('opportunities')
            .select('location')
            .not('location', 'is', null);
        
        if (error) throw error;
        
        const uniqueLocations = [...new Set(data.map(item => item.location))]
            .filter(location => location && location.trim() !== '')
            .sort();
        
        return { success: true, data: uniqueLocations };
    } catch (error) {
        console.error('Get unique locations error:', error);
        return { success: false, error: error.message };
    }
}

// ... existing code ...
    async signInUser(email, password) {
        try {
            if (!(await this.ensureInitialized())) {
                throw new Error('Supabase client not available');
            }
            const { data, error } = await this.supabase.auth.signInWithPassword({
                email,
                password
            });
            
            if (error) throw error;
            
            // Get additional user data from users table
            const { data: userData, error: userError } = await this.supabase
                .from('users')
                .select('*')
                .eq('id', data.user.id)
                .single();
            
            if (userError) console.warn('Could not fetch user data:', userError);
            
            return { 
                success: true, 
                data: {
                    ...data,
                    userData: userData
                }
            };
        } catch (error) {
            console.error('Sign in error:', error);
            return { success: false, error: error.message };
        }
    }

    async signOutUser() {
        try {
            if (!this.supabase) {
                throw new Error('Supabase client not available');
            }
            const { error } = await this.supabase.auth.signOut();
            if (error) throw error;
            return { success: true };
        } catch (error) {
            console.error('Sign out error:', error);
            return { success: false, error: error.message };
        }
    }

    async getCurrentUser() {
        try {
            if (!(await this.ensureInitialized())) {
                return { success: false, error: 'Supabase client not available' };
            }
            
            const { data: { user }, error: authError } = await this.supabase.auth.getUser();
            if (authError) {
                console.error('Auth getUser error:', authError);
                return { success: false, error: authError.message };
            }
            
            if (!user) return { success: false, error: 'No user logged in' };
            
            // Get additional user data with retry logic for new registrations
            let userData = null;
            let retryCount = 0;
            const maxRetries = 3;
            
            while (retryCount < maxRetries) {
                const { data, error } = await this.supabase
                    .from('users')
                    .select('*')
                    .eq('id', user.id)
                    .single();
                
                if (!error && data) {
                    userData = data;
                    break;
                }
                
                if (error && error.code !== 'PGRST116') { // PGRST116 is "not found" error
                    console.error('User data fetch error:', error);
                    return { success: false, error: error.message };
                }
                
                // If user not found, wait a bit and retry (for new registrations)
                retryCount++;
                if (retryCount < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }
            
            return { 
                success: true, 
                data: {
                    authUser: user,
                    userData: userData
                }
            };
        } catch (error) {
            console.error('getCurrentUser error:', error);
            return { success: false, error: error.message };
        }
    }

    // ==================== OPPORTUNITY MANAGEMENT ====================
    
    async createOpportunity(opportunityData) {
        try {
            if (!(await this.ensureInitialized())) {
                throw new Error('Supabase client not available');
            }
            const { data: { user } } = await this.supabase.auth.getUser();
            if (!user) throw new Error('User must be logged in');
            
            const { data, error } = await this.supabase
                .from('opportunities')
                .insert([{
                    ...opportunityData,
                    provider_id: user.id,
                    created_at: new Date().toISOString()
                }])
                .select();
            
            if (error) throw error;
            return { success: true, data };
        } catch (error) {
            console.error('Create opportunity error:', error);
            return { success: false, error: error.message };
        }
    }

    async getOpportunities(filters = {}) {
        try {
            if (!(await this.ensureInitialized())) {
                throw new Error('Supabase client not available');
            }
            let query = this.supabase
                .from('opportunities')
                .select('*');
            
            if (filters.category) {
                query = query.eq('category', filters.category);
            }
            if (filters.location) {
                query = query.ilike('location', `%${filters.location}%`);
            }
            if (filters.providerId) {
                query = query.eq('provider_id', filters.providerId);
            }
            
            const { data, error } = await query.order('created_at', { ascending: false });
            if (error) throw error;
            return { success: true, data: data || [] };
        } catch (error) {
            console.error('Get opportunities error:', error);
            return { success: false, data: [], error: error.message };
        }
    }

    // ==================== APPLICATION MANAGEMENT ====================
    
    async submitApplication(applicationData) {
        try {
            if (!(await this.ensureInitialized())) {
                throw new Error('Supabase client not available');
            }
            const { data: { user } } = await this.supabase.auth.getUser();
            if (!user) throw new Error('User must be logged in');
            
            const { data, error } = await this.supabase
                .from('applications')
                .insert([{
                    ...applicationData,
                    seeker_id: user.id,
                    status: 'pending',
                    created_at: new Date().toISOString()
                }])
                .select();
            
            if (error) throw error;
            return { success: true, data };
        } catch (error) {
            console.error('Submit application error:', error);
            return { success: false, error: error.message };
        }
    }

    async getApplications(userId, userType = 'seeker') {
        try {
            if (!(await this.ensureInitialized())) {
                throw new Error('Supabase client not available');
            }
            let query = this.supabase
                .from('applications')
                .select(`
                    *,
                    opportunities(*),
                    users!applications_seeker_id_fkey(full_name, email)
                `);
            
            if (userType === 'seeker') {
                query = query.eq('seeker_id', userId);
            } else {
                // For providers, get applications for their opportunities
                query = query.eq('opportunities.provider_id', userId);
            }
            
            const { data, error } = await query.order('created_at', { ascending: false });
            if (error) throw error;
            return { success: true, data };
        } catch (error) {
            console.error('Get applications error:', error);
            return { success: false, error: error.message };
        }
    }

    // ==================== MESSAGING SYSTEM ====================
    
    async getMessages(conversationId) {
        try {
            if (!(await this.ensureInitialized())) {
                throw new Error('Supabase client not available');
            }
            const { data, error } = await this.supabase
                .from('messages')
                .select(`
                    *,
                    sender:users!messages_sender_id_fkey(full_name, email)
                `)
                .eq('conversation_id', conversationId)
                .order('created_at', { ascending: true });
            
            if (error) throw error;
            return { success: true, data };
        } catch (error) {
            console.error('Get messages error:', error);
            return { success: false, error: error.message };
        }
    }

    async sendMessage(messageData) {
        try {
            if (!(await this.ensureInitialized())) {
                throw new Error('Supabase client not available');
            }
            const { data: { user } } = await this.supabase.auth.getUser();
            if (!user) throw new Error('User must be logged in');
            
            // First, ensure conversation exists
            const conversationResult = await this.getOrCreateConversation(
                messageData.senderId || user.id,
                messageData.receiverId
            );
            
            if (!conversationResult.success) {
                throw new Error('Failed to create conversation');
            }
            
            const { data, error } = await this.supabase
                .from('messages')
                .insert([{
                    conversation_id: conversationResult.data.id,
                    sender_id: user.id,
                    content: messageData.content,
                    created_at: new Date().toISOString()
                }])
                .select();
            
            if (error) throw error;
            return { success: true, data };
        } catch (error) {
            console.error('Send message error:', error);
            return { success: false, error: error.message };
        }
    }

    async getOrCreateConversation(participant1Id, participant2Id) {
        try {
            if (!(await this.ensureInitialized())) {
                throw new Error('Supabase client not available');
            }
            // Check if conversation already exists
            const { data: existing, error: searchError } = await this.supabase
                .from('conversations')
                .select('*')
                .or(`and(participant1.eq.${participant1Id},participant2.eq.${participant2Id}),and(participant1.eq.${participant2Id},participant2.eq.${participant1Id})`)
                .limit(1);
            
            if (searchError) throw searchError;
            
            if (existing && existing.length > 0) {
                return { success: true, data: existing[0] };
            }
            
            // Create new conversation
            const { data, error } = await this.supabase
                .from('conversations')
                .insert([{
                    participant1: participant1Id,
                    participant2: participant2Id,
                    created_at: new Date().toISOString()
                }])
                .select()
                .single();
            
            if (error) throw error;
            return { success: true, data };
        } catch (error) {
            console.error('Get/Create conversation error:', error);
            return { success: false, error: error.message };
        }
    }

    async getConversations(userId) {
        try {
            if (!(await this.ensureInitialized())) {
                throw new Error('Supabase client not available');
            }
            const { data, error } = await this.supabase
                .from('conversations')
                .select(`
                    *,
                    messages(content, created_at, sender_id),
                    participant1_user:users!conversations_participant1_fkey(full_name, email),
                    participant2_user:users!conversations_participant2_fkey(full_name, email)
                `)
                .or(`participant1.eq.${userId},participant2.eq.${userId}`)
                .order('updated_at', { ascending: false });
            
            if (error) throw error;
            return { success: true, data };
        } catch (error) {
            console.error('Get conversations error:', error);
            return { success: false, error: error.message };
        }
    }

    // ==================== DATA MIGRATION ====================
    
    async migrateLocalStorageData() {
        try {
            if (!(await this.ensureInitialized())) {
                console.warn('Supabase client not available for migration');
                return;
            }
            
            console.log('Starting localStorage migration...');
            
            // Note: This is a one-time migration function
            // In production, you'd want to be more careful about data validation
            
            const migrationResults = {
                users: 0,
                opportunities: 0,
                applications: 0,
                messages: 0
            };
            
            // Migrate users (if any stored locally)
            const localUsers = JSON.parse(localStorage.getItem('kajopo_users') || '[]');
            console.log(`Found ${localUsers.length} local users to migrate`);
            
            // Migrate opportunities
            const localOpportunities = JSON.parse(localStorage.getItem('kajopo_opportunities') || '[]');
            console.log(`Found ${localOpportunities.length} local opportunities to migrate`);
            
            // Migrate applications
            const localApplications = JSON.parse(localStorage.getItem('kajopo_applications') || '[]');
            console.log(`Found ${localApplications.length} local applications to migrate`);
            
            // Migrate messages
            const localMessages = JSON.parse(localStorage.getItem('kajopo_messages') || '[]');
            console.log(`Found ${localMessages.length} local messages to migrate`);
            
            console.log('Migration completed:', migrationResults);
            return { success: true, results: migrationResults };
        } catch (error) {
            console.error('Migration failed:', error);
            return { success: false, error: error.message };
        }
    }

    // ==================== REAL-TIME SUBSCRIPTIONS ====================
    
    async subscribeToMessages(conversationId, callback) {
        if (!(await this.ensureInitialized())) {
            console.error('Supabase client not available');
            return null;
        }
        return this.supabase
            .channel(`messages:${conversationId}`)
            .on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'messages',
                filter: `conversation_id=eq.${conversationId}`
            }, callback)
            .subscribe();
    }

    async subscribeToOpportunities(callback) {
        if (!(await this.ensureInitialized())) {
            console.error('Supabase client not available');
            return null;
        }
        return this.supabase
            .channel('opportunities')
            .on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'opportunities'
            }, callback)
            .subscribe();
    }
}

// Initialize and export
window.dbManager = new DatabaseManager();
console.log('Database Manager initialized successfully');